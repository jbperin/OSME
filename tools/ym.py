import lhafile
import struct

# %osdk%\bin\ym2mym.exe data\bach.YM %osdk%\TMP\bach.mym
# %osdk%\bin\bin2txt -f2 -h1 -s1 %osdk%\TMP\bach.mym  music.s _Music

# http://leonard.oxg.free.fr/ymformat.html
# https://github.com/skeezix/zikzak/blob/master/zik80/audio-gen/ym-file-format.txt
# BYTE unsigned 8 bits integer
# WORD unsigned 16 bits integer (Big Endian format)
# LWORD unsigned 32 bits integer (Big Endian format)
# STRING[n] Ascci text string of n characters
# NT-String Null terminated string.

# 0 LWORD 4	File ID "YM6!"
# 4 STRING[8] 8 Check string "LeOnArD!"
# 12 LWORD 4 Nb of frame in the file
# 16 LWORD 4 Song attributes
# 20 WORD 2 Nb of digidrum samples in file (can be 0)
# 22 LWORD 4 YM master clock implementation in Hz .(ex:2000000 for ATARI-ST version, 1773400 for ZX-SPECTRUM)
# 26 WORD 2 Original player frame in Hz (traditionnaly 50)
# 28 LWORD 4 Loop frame (traditionnaly 0 to loop at the beginning)
# 32 WORD 2 Size, in bytes, of futur additionnal data. You have to skip these bytes. (always 0 for the moment)
# Then, for each digidrum: (nothing if no digidrum)
# 34 LWORD 4 Sample size
# 38 BYTES n Sample data (8 bits sample)
# Then some additionnal informations
# ? NT-String ? Song name
# ? NT-String ? Author name
# ? NT-String ? Song comment
# ? BYTES ? YM register data bytes. (r0,r1,r2....,r15 for each frame). Order depend on the "interleaved" bit. It takes 16*nbFrame bytes.
# ? LWORD 4 End ID marker. Must be "End!"


# http://leonard.oxg.free.fr/ymformat.html#ymchip

#http://ym2149.org/resources/YM-format.txt


# Archive of musics: 
# https://bulba.untergrund.net/music_e.htm
# https://vgmrips.net/packs/chip/ay-3-8910
# https://www.smspower.org/uploads/Music/vgmspec160.txt


def readNullTerminatedString(bytes_read, idx_data):
    chars = []
    idx=idx_data
    while True:
        c = bytes_read[idx]
        # print (idx_data, c)
        idx = idx+1
        if c == 0:
            res = "".join(chars)
            break
        
        chars.append(chr(c))
    return idx, res

def writeNullTerminatedString(bytes_buf, data):
    # print (data, bytes(data, 'utf-8'))
    bytes_buf += bytes(data, 'utf-8')
    # print (bytes_buf)
    bytes_buf += bytes('\0', 'utf-8')
    return bytes_buf

listOfRegister = ['r0','r1','r2','r3','r4','r5','r6','r7','r10','r11','r12','r13','r14','r15','r16','r17']

class YM:
    def __init__(self, ):
        self.header = {
            'idFormat':b'YM6!',
            'checkString':b'LeOnArD!',
            'nbFrames':0,
            'songAttributes':0,
            'nbDigidrum':0,
            'masterClockHz':1000000,
            'origPlayerFrames':50,
            'loopFrame':0,
            'size':0,
            'songTitle':'Untitled',
            'authorName':'YM',
            'songComment':'Generated by Jibe tools'
        } 
        self.frames=[]   
    def addFrame (self, frame):
        theFrame = {}
        if (len(self.frames)==0):
            for reg in listOfRegister:
                theFrame[reg] = frame.get(reg, 0)
            self.frames.append(theFrame)
        else:
            last_frame = self.frames[-1]
            for reg in listOfRegister:
                theFrame[reg] = frame.get(reg, last_frame[reg])
            self.frames.append(theFrame)
        self.header['nbFrames'] += 1
    def _ym5decode(self, buffer):
        self._ym6decode(buffer)
    def _ym6decode(self, buffer):
        s = struct.Struct('>4s 8s I I H I H I H')
        unpacked = s.unpack(buffer[0:s.size])
        self.header = {
            'idFormat':unpacked[0],
            'checkString':unpacked[1],
            'nbFrames':unpacked[2],
            'songAttributes':unpacked[3],
            'nbDigidrum':unpacked[4],
            'masterClockHz':unpacked[5],
            'origPlayerFrames':unpacked[6],
            'loopFrame':unpacked[7],
            'size':unpacked[8],
        }    
        idx_data = s.size
        idx_data , self.header['songTitle']=readNullTerminatedString(buffer, idx_data)
        idx_data , self.header['authorName']=readNullTerminatedString(buffer, idx_data)
        idx_data , self.header['songComment']=readNullTerminatedString(buffer, idx_data)
        print (self.header)
        self.frames=[]
        if (self.header['songAttributes'] %  2 ==1):
            print ('interleaved')
            for ii in range (self.header['nbFrames']):
                # print (ii)
                frame= {'r0' : buffer[idx_data], 
                        'r1' : buffer[idx_data+ 1*self.header['nbFrames']],
                        'r2' : buffer[idx_data+ 2*self.header['nbFrames']],
                        'r3' : buffer[idx_data+ 3*self.header['nbFrames']],
                        'r4' : buffer[idx_data+ 4*self.header['nbFrames']],
                        'r5' : buffer[idx_data+ 5*self.header['nbFrames']],
                        'r6' : buffer[idx_data+ 6*self.header['nbFrames']],
                        'r7' : buffer[idx_data+ 7*self.header['nbFrames']],
                        'r10': buffer[idx_data+ 8*self.header['nbFrames']],
                        'r11': buffer[idx_data+ 9*self.header['nbFrames']],
                        'r12': buffer[idx_data+10*self.header['nbFrames']],
                        'r13': buffer[idx_data+11*self.header['nbFrames']],
                        'r14': buffer[idx_data+12*self.header['nbFrames']],
                        'r15': buffer[idx_data+13*self.header['nbFrames']],
                        'r16': buffer[idx_data+14*self.header['nbFrames']],
                        'r17': buffer[idx_data+15*self.header['nbFrames']]}
                idx_data = idx_data + 1
                # print (frame)
                self.frames.append(frame)
            idx_data += 15*self.header['nbFrames']
        else:
            print ('non interleaved not properly  handled')
            r = struct.Struct('>B B B B B B B B B B B B B B B B')
            for i in range(self.header['nbFrames']):
            
                unpacked = r.unpack(buffer[idx_data:idx_data+r.size])
                idx_data=idx_data+r.size
                # print (unpacked)
                frame= {'r0' : unpacked[0], 
                        'r1' : unpacked[ 1],
                        'r2' : unpacked[ 2],
                        'r3' : unpacked[ 3],
                        'r4' : unpacked[ 4],
                        'r5' : unpacked[ 5],
                        'r6' : unpacked[ 6],
                        'r7' : unpacked[ 7],
                        'r10': unpacked[ 8],
                        'r11': unpacked[ 9],
                        'r12': unpacked[10],
                        'r13': unpacked[11],
                        'r14': unpacked[12],
                        'r15': unpacked[13],
                        'r16': unpacked[14],
                        'r17': unpacked[15]}
                # print (frame)
                self.frames.append(frame)
        
        unpacked = struct.unpack(">4s", buffer[idx_data:idx_data+4] )
        print (unpacked)

    def export(self, filepath):

        s = struct.Struct('>4s 8s I I H I H I H')
        buffer = s.pack(
            self.header['idFormat'],
            self.header['checkString'],
            self.header['nbFrames'],
            self.header['songAttributes'],
            self.header['nbDigidrum'],
            self.header['masterClockHz'],
            self.header['origPlayerFrames'],
            self.header['loopFrame'],
            self.header['size'],
        )
        buffer= writeNullTerminatedString(buffer,self.header['songTitle'])
        buffer= writeNullTerminatedString(buffer,self.header['authorName'])
        buffer= writeNullTerminatedString(buffer,self.header['songComment'])
        if (self.header['songAttributes'] %  2 ==1):
            # print ('interleaved')
            # for ii in range (self.header['nbFrames']):
            for reg in listOfRegister:
                allwritereg = [fra[reg] for fra in self.frames]
                for wri in allwritereg:
                    buffer += bytes(wri)
        else:
            r = struct.Struct('>B B B B B B B B B B B B B B B B')
            for fra in self.frames:
                buffer += r.pack(
                    fra['r0'],
                    fra['r1'],
                    fra['r2'],
                    fra['r3'],
                    fra['r4'],
                    fra['r5'],
                    fra['r6'],
                    fra['r7'],
                    fra['r10'],
                    fra['r11'],
                    fra['r12'],
                    fra['r13'],
                    fra['r14'],
                    fra['r15'],
                    fra['r16'],
                    fra['r17'],
                )

        buffer += b'End!'
        with open (filepath, "wb") as ficout:
            ficout.write(buffer)


    def load(self,filepath):
        with open (filepath, "rb") as ficin:
            buffer = ficin.read()
        format = struct.unpack("4s", buffer[0:4])[0].decode("utf-8")
        if format in ['YM2!', 'YM3!', 'YM4!', 'YM5!', 'YM6!']:
            print (f"Not compressed format:  {format}")
            print (len(buffer))
        else:
            lha = lhafile.Lhafile(filepath)
            files = [info.filename for info in lha.infolist()]
            filename = files[0]
            buffer = lha.read(filename)
            print (len(buffer))
            format = struct.unpack('4s',buffer[0:4])[0].decode("utf-8")
            if format in ['YM2!', 'YM3!', 'YM4!', 'YM5!', 'YM6!']:
                print (f"LHA compressed format:  {format}")
            else:
                print (f"Unrecognized YM format ..")
                return
        if (format == 'YM2!'):
            pass
        elif (format == 'YM3!'):
            pass
        elif (format == 'YM4!'):
            pass
        elif (format == 'YM5!'):
            self._ym5decode(buffer)
        elif (format == 'YM6!'):
            self._ym6decode(buffer)

def main ():
    aYM = YM()
    aYM.load('C:\\Perso\\myCode\\OSME\\tools\\alien_frame.ym')

    anOtherYM = YM()
    # print (aYM.header['nbFrames'], )
    for i in range(aYM.header['nbFrames']):
        # print (aYM.frames[i])
        anOtherYM.addFrame(aYM.frames[i])
    anOtherYM.header['loopFrame'] = aYM.header['loopFrame']
    anOtherYM.header['songTitle'] = aYM.header['songTitle']
    anOtherYM.header['authorName'] = aYM.header['authorName']
    anOtherYM.header['songComment'] = aYM.header['songComment']
    # for i in range(5):
    #     print (anOtherYM.frames[i])
    anOtherYM.export('C:\\Perso\\myCode\\OSME\\tools\\alien_frame_bis.ym')

if __name__ == '__main__':
    main()
